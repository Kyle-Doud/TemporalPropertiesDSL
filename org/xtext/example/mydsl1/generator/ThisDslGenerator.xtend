/*
 * generated by Xtext
 */
package org.xtext.example.mydsl1.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.xtext.example.mydsl1.thisDsl.Evidences
import java.io.FileWriter
import java.io.File
import java.io.BufferedWriter

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ThisDslGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(ev : resource.allContents.toIterable().filter(Evidences))
		fsa.generateFile('Main.java', generateDriver(ev))
		fsa.generateFile('Query.java', generateQuery())
		fsa.generateFile('EvidenceTesting.java', generateEvidenceTesting())
		fsa.generateFile('FileGenerator.java', generateFileGenerator())
		fsa.generateFile('Condition.java', generateCondition())
		fsa.generateFile('FSA.java', generateFSA())
		fsa.generateFile('State.java', generateState())
		fsa.generateFile('DataRecord.java', generateDataRecord())
		fsa.generateFile('DataRecordManager.java', generateDataRecordManager())
		fsa.generateFile('DataType.java', generateDataType())
		fsa.generateFile('DataTypeBoolean.java', generateDataTypeBoolean())
		fsa.generateFile('DataTypeDouble.java', generateDataTypeDouble())
		fsa.generateFile('DataTypeInt.java', generateDataTypeInt())
		fsa.generateFile('DataTypeLong.java', generateDataTypeLong())
		fsa.generateFile('DataTypeString.java', generateDataTypeString())
	}
	
	def generateCondition()'''
	package FSACreation;

import DataRecording.DataType;

/**
 * This class represents a single condition of a state within an FSA. 
 * This condition can either specify a single value or a range of values.
 */
public class Condition {
	
	private boolean initialized;
	private DataType low;
	private DataType high;
	//private int agentId;

	
	/**
	 * Instantiates a Condition object that represents a single value
	 * @param singleConditionValue A single value
	 */
	public Condition(DataType singleConditionValue) {
		if (singleConditionValue.isInitialized()) {
			initialized = true;
			this.low = singleConditionValue;
			this.high = singleConditionValue;
		} else {
			this.initialized = false;
		}
	}

	
	/**
	 * Create a new Condition object that represents a range.
	 * DataType that represents a boolean cannot be used to define a range.
	 * @param low The bottom value in a range, inclusive
	 * @param high The highest value in a range, exclusive
	 */
	public Condition(DataType low, DataType high) {
		this.low = low;
		this.high = high;
		this.initialized = true;
		assert(low.compareTo(high) < 0);
	}

	
	/**
	 * This condition is satisfied by equality if the condition represents a
	 * single value. If the condition represents a range of values, the
	 * condition is satisfied by the value if it falls within this range.
	 * An uninitialized condition is satisfied only by an uninitialized value.
	 * @return whether the provided value 'satisfies' this condition
	 */
	boolean isConditionSatisfiedBy(DataType value) {
		
		// An uninitialized value satisfies an uninitialized condition value.
		if (!initialized && !value.isInitialized())
			return true;

		// If this condition's value definition has not been initialized,
		// it cannot be satisfied by any initialized value
		if (!initialized && value.isInitialized())
			return false;
		
		// If query value has not been initialized,
		// it cannot be satisfied by an initialized condition value.
		if (initialized && !value.isInitialized())
			return false;

		
		// This condition is a single value; evaluate for equality.
		if (low.compareTo(high) == 0) {
			if (low.compareTo(value) == 0) {
				return true;
			} else {
				return false;
			}
		}
		
		// This condition is a range;
		// evaluate whether the value falls inside this range
		else if ((low.compareTo(value) <= 0) && (high.compareTo(value) > 0)) {
			return true;
		}

		return false;
	}
	
	
	/**
	 * Determines if this condition object is equal to a condition with the 
	 * specified values. This method is used when manually defining states from
	 * the DSL and 
	 * @param vLow
	 * @param vHigh
	 * @return
	 */
	boolean isConditionEqual(DataType vLow, DataType vHigh) {

		// An uninitialized value is equal to an uninitialized condition value.
		if (!initialized && !vLow.isInitialized() && !vHigh.isInitialized())
			return true;

		// If one or two (but not all) of the values are not initialized,
		// they cannot be equal to an initialized value.
		if (!initialized || !vLow.isInitialized() || !vHigh.isInitialized())
			return false;
		
		// Evaluate condition values for equality
		return ((low.compareTo(vLow) == 0) && (high.compareTo(vHigh) == 0));
	}
	

	/**
	 * Generates a String representation of this condition.
	 * Has the form: "(singleValue)" or "(lowValue, highValue)"
	 */
	public String toString() {
		String output = "";
		if (!initialized)
			output += "(null)";
		else if (low == high)
			output += "(" + low + ")";
		else 
			output += "(" + low + ", " + high + ")";
		return output;
	}
}
	
	'''
	def generateFSA()'''
	package FSACreation;
import java.util.*;

import DataRecording.DataType;
import DataRecording.DataTypeBoolean;
import DataRecording.DataTypeDouble;
import DataRecording.DataTypeInt;
import DataRecording.DataTypeLong;
import DataRecording.DataTypeString;

public class FSA {
	
	/* Number of methods that are of interest in the model, and are recorded.
	 * Number of variables are used as conditions for the States in this FSA.
	 */
	private int numVariables;
	private ArrayList<State> states;

	
	/** 
	 * Constructor for a new, empty FSA.
	 * @param numVariables The number of variables recorded from the model
	 * 		& also the number of variables considered when evaluating states
	 */
	public FSA(int numVariables) {
		this.numVariables = numVariables;
		states = new ArrayList<State>();
	}
	
	
	/** @return the number of states that have been defined for this FSA */
	public int getNumStates() {
		return this.states.size();
	}

	
	/**
	 * Parse a matrix of data obtained from the execution of the model, and add
	 * to the FSA, any state or transition represented by this data sequence
	 * that is not already present in the FSA.
	 * @param allData The matrix obtained from parsing the data file.
	 */
	public void developFSAFromData(ArrayList<DataType[]> allData) {
		// Obtain the first state, which should be all uninitialized values
		DataType[] firstDataSet = allData.get(0);
		int firstStateIndex = retrieveState(firstDataSet);
		State currentState = states.get(firstStateIndex);

		// Analyze the rest of the data, and add new states to the FSA if needed
		for (int numAnalyzed = 1; numAnalyzed < allData.size(); numAnalyzed++) {
		 	DataType[] nextDataSet = allData.get(numAnalyzed);
			if (currentState.isStateSatisfiedBy(nextDataSet)) {
				// remain in the same state
				currentState.addTransitionIfNotPresent(currentState.getIndex());
			} else {
				int nextStateIndex = retrieveState(nextDataSet);
				currentState.addTransitionIfNotPresent(nextStateIndex);
				currentState = states.get(nextStateIndex);
			}
		}
	}
	
	
	/**
	 * Searches the existing states in the FSA for one that is satisfied by the
	 * specified values. If no matching state is found, a new state is created
	 * and added to the FSA.
	 * @param dataValues the target values of each variable in this state
	 * @return the index in the states array of the state these values satisfy
	 */
	private int retrieveState(DataType[] dataValues) {
		for (int i = 0; i < states.size(); i++) {
			if (states.get(i).isStateSatisfiedBy(dataValues))
				return i;
		}
		int newIndex = states.size();
		states.add(new State(newIndex, dataValues, true));
		return newIndex;
	}
	
	
	/**
	 * Create a String representation of this FSA.
	 */
	public String toString() {
		String output = "Number of states in the FSA: " + states.size() + "\n";
		for (int i = 0; i < states.size(); i++) {
			State s = states.get(i);
			output += "\nState " + s.getIndex() + ":";
			output += s.toString();
		}
		return output;
	}
	
	
	
	/**
	 * This class is used to define states 'manually' from information provided
	 * by the DSL. 
	 */
	public class StateDefinitionBuilder {
		
		HashMap<String, Integer> variableNameIndexMap;
		
		
		DataType[] dataValues;
		
		
		/**
		 * Constructor for a new StateDefinitionManager. This object will allow
		 * you to define a new state for the FSA manually (as opposed to
		 * defining new states from the data recorded). 
		 * @param varNameIndices
		 * @param varTypes
		 */
		public StateDefinitionBuilder(HashMap<String, Integer> varNameIndices) {
			variableNameIndexMap = varNameIndices;
			dataValues = new DataType[numVariables * 2];
		}

		
		/**
		 * Creates a new state from the information that has been provided to
		 * this StateDefinitionManager object. 
		 * @return index of the new state that has been created. Returns -1 if 
		 *    there is one or more variables that do not have a condition defined
		 */
		public int createState() {
			// verify all info has been added
			for (int i = 0; i < dataValues.length; i++) {
				if (dataValues[i] == null) {
					// Cannot define a state without defining state values for all variables.
					return -1;
				}
			}
			int newIndex = states.size();
			states.add(new State(newIndex, dataValues, false));
			return newIndex;
		}
		
		
		/**
		 * Define a new condition for this state. Will override any previous
		 * value(s) assigned for this variable during this state definition.
		 * @param variable Name of the variable to define a condition for
		 * @param valueLow The low end of a range value, or a single value
		 * @param valueHigh The high end of a range value, or a single value
		 */
		private boolean defineStateCondition(String variable,
				DataType valueLow, DataType valueHigh) {
			int index = variableNameIndexMap.get(variable);
			int lowIndex = index * 2;
			int highIndex = index * 2 + 1;
			dataValues[lowIndex] = valueLow;
			dataValues[highIndex] = valueHigh;
			return true;
		}
		
		
		public void defineStateCondition(String variable, boolean value) {
			defineStateCondition(variable, new DataTypeBoolean(value), new DataTypeBoolean(value));
		}
		
		public void defineStateCondition(String variable, boolean valueLow, boolean valueHigh) {
			if (valueLow != valueHigh)
				throw new IllegalArgumentException("Invalid condition values. "
					+ "Cannot define a range for boolean values");
				
			defineStateCondition(variable, new DataTypeBoolean(valueLow), new DataTypeBoolean(valueHigh));
		}
		
		public void defineStateCondition(String variable, double value) {
			defineStateCondition(variable, new DataTypeDouble(value), new DataTypeDouble(value));
		}
		
		public void defineStateCondition(String variable, double valueLow, double valueHigh) {
			if (valueLow > valueHigh)
				throw new IllegalArgumentException("Invalid condition values. "
						+ valueLow + " should not be greater than " + valueHigh);
			defineStateCondition(variable, new DataTypeDouble(valueLow), new DataTypeDouble(valueHigh));
		}
		
		public void defineStateCondition(String variable, int value) {
			defineStateCondition(variable, new DataTypeInt(value), new DataTypeInt(value));
		}
		
		public void defineStateCondition(String variable, int valueLow, int valueHigh) {
			if (valueLow > valueHigh)
				throw new IllegalArgumentException("Invalid condition values. "
						+ valueLow + " should not be greater than " + valueHigh);
			defineStateCondition(variable, new DataTypeInt(valueLow), new DataTypeInt(valueHigh));
		}
		
		public void defineStateCondition(String variable, long value) {
			defineStateCondition(variable, new DataTypeLong(value), new DataTypeLong(value));
		}
		
		public void defineStateCondition(String variable, long valueLow, long valueHigh) {
			if (valueLow > valueHigh)
				throw new IllegalArgumentException("Invalid condition values. "
						+ valueLow + " should not be greater than " + valueHigh);
			defineStateCondition(variable, new DataTypeLong(valueLow), new DataTypeLong(valueHigh));
		}

		public void defineStateCondition(String variable, String value) {
			defineStateCondition(variable, new DataTypeString(value), new DataTypeString(value));
		}
		
		public void defineStateCondition(String variable, String valueLow, String valueHigh) {
			if (valueLow.compareTo(valueHigh) > 0)
				throw new IllegalArgumentException("Invalid condition values. "
						+ valueLow + " should not be greater than " + valueHigh);
			defineStateCondition(variable, new DataTypeString(valueLow), new DataTypeString(valueHigh));
		}
	}
}
	
	'''
	def generateState()'''
	package FSACreation;
import java.util.ArrayList;

import DataRecording.DataType;

public class State {

	private int index;
	private Condition[] conditions;
	private ArrayList<Integer> transitions;

	
	/**
	 * Create a new State object
	 * @param newIndex Index this state is stored at in the FSA's states array
	 * @param newDataValues Values representing the condition values
	 * 		for each variable in this state.
	 * @param fromData Whether this State is being defined from reading data
	 * 		or from a manual definition from information in the DSL
	 */
	public State(int newIndex, DataType[] newDataValues, boolean fromData) {
		if (fromData) {
			Condition[] newConditions = new Condition[newDataValues.length]; 
			// state is defined by parsing data. there will be no range conditions
			for (int i = 0; i < newDataValues.length; i++)
				newConditions[i] = new Condition(newDataValues[i]);
			this.index = newIndex;
			this.conditions = newConditions;
			transitions = new ArrayList<Integer>();
		} else {
			int numConditions = newDataValues.length / 2;
			Condition[] newConditions = new Condition[numConditions]; 
			for (int i = 0; i < (numConditions); i++) {
				if (newDataValues[i*2].compareTo(newDataValues[i*2+1]) == 0) {
					newConditions[i] = new Condition(newDataValues[i*2]);
				}
				else {
					// range condition
					newConditions[i] = new Condition(newDataValues[i*2],
										newDataValues[i*2 + 1]);
				}
			}
			this.index = newIndex;
			this.conditions = newConditions;
			transitions = new ArrayList<Integer>();
		}
	}
	
	
	/**
	 * Create a new State object. This is used when defining new states 
	 * that represent ranges of values.
	 * @param newIndex Index this state is stored at in the FSA's states array
	 * @param newDataValues Values representing the condition values
	 * for each variable in this state.
	 */
	public State(int newIndex, Condition[] newConditions) {
		this.index = newIndex;
		this.conditions = newConditions;
		transitions = new ArrayList<Integer>();
	}

	
	/**
	 * Determines whether a set of values fit the definition of this state.
	 * @param dataValues Values of variables at a specific point of time
	 * @return true if these values satisfy every condition of this state
	 */
	boolean isStateSatisfiedBy(DataType[] dataValues) {
		for (int i = 0; i < this.conditions.length; i++) {
			Condition stateCondition = this.conditions[i];
			if (!stateCondition.isConditionSatisfiedBy(dataValues[i]))
				return false;
		}
		return true;
	}

	boolean isStateEqual(DataType[] dataValues) {
		for (int i = 0; i < this.conditions.length; i++) {
			Condition stateCondition = this.conditions[i];
			if (!stateCondition.isConditionEqual(dataValues[i], dataValues[i + 1]))
				return false;
		}
		return true;
	}
	
	/**
	 * Adds a transition between this state and the state found at the provided
	 * index in the FSA's states array, if this transition does not already
	 * exist in the current FSA.
	 * @param nextStateIndex The index of the next state
	 */
	void addTransitionIfNotPresent(int nextStateIndex) {
		if (!this.transitions.contains(nextStateIndex))
			this.transitions.add(nextStateIndex);
	}

	
	/**
	 * @return true if there is a transition between this state and the state
	 * at the provided index
	 */
	boolean isTransitionPresent(int nextStateIndex) {
		return this.transitions.contains(nextStateIndex);
	}

	
	/**
	 * @return the index this state is stored at in the array of states for
	 * the current FSA
	 */
	public int getIndex() {
		return index;
	}
	
	
	/** Generate a String representation of this state */
	public String toString() {
		String output = "\tConditions: ";
		for (Condition c : this.conditions) {
			output += c.toString() + " ";
		}
		output += "\n\t\tTransitions: ";
		for (int i = 0; i < transitions.size(); i++) {
			output += transitions.get(i);
			if (i != transitions.size() - 1)
				output += ", ";
		}
		return output;
	}
}
	
	'''
	def generateDataRecord()'''
	package DataRecording;
/**
 * This class represents a single data value recorded from a function during
 * the model execution.
 */
public class DataRecord {
	
	String variableName;
	DataType data;
	
	public DataRecord(String variableName, DataType dataToRecord) {
		this.variableName = variableName;
		this.data = dataToRecord;
	}
	
	public String toString() {
		return (variableName + "\t" + data);
	}
}
	'''
	def generateDataRecordManager()'''
	package DataRecording;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;


public class DataRecordManager {
	
	private int numVariables;
	private File dataFile;
	
	private ArrayList<DataRecord> dataRecordList;  // data recorded from a single run
	
	private HashMap<String, Integer> variableIndexMap;	// key: variable name, value: variable index in matrix
	private HashMap<String, String> variableTypeMap;	// key: variable name, value: variable type
	private String[] variableNamesList; 	// list of variable names, where the index of each name corresponds to its index in the matrix

	
	/**
	 * Constructor for a DataRecordManager object.
	 * @param numVariables Number of methods/variables recorded from the model
	 * @param dataStorageLocation The path and file name of the txt file where
	 * 	the data is stored
	 */
	public DataRecordManager(int numVariables, String dataStorageLocation) {
		this.numVariables = numVariables;
		dataRecordList = new ArrayList<DataRecord>();
		dataFile = new File(dataStorageLocation);
	}
	
	
	/**
	 * Records the result from a method executing in the repast model execution.
	 * @param methodEventName The name of the method/variable.
	 * @param data	The result returned from the event execution.
	 * Accepts DataTypeBoolean, DataTypeDouble, DataTypeInt, DataTypeString.
	 */
	private void recordData(String methodEventName, DataType data) {
		DataRecord newRecord = new DataRecord(methodEventName, data);
		dataRecordList.add(newRecord);
	}

	
	/**
	 * Records the result from a method executing in the repast model execution, 
	 *  when the method has a return type int.
	 * @param methodEventName The name of the method/variable.
	 * @param data	The result returned from the event execution.
	 */
	public void recordData(String methodEventName, int data) {
		recordData(methodEventName, new DataTypeInt(data));
	}

	
	/**
	 * Records the result from a method executing in the repast model execution, 
	 *  when the method has a return type double.
	 * @param methodEventName The name of the method/variable.
	 * @param data	The result returned from the event execution.
	 */
	public void recordData(String methodEventName, double data) {
		recordData(methodEventName, new DataTypeDouble(data));
	}
	
	
	/**
	 * Records the result from a method executing in the repast model execution, 
	 *  when the method has a return type long.
	 * @param methodEventName The name of the method/variable.
	 * @param data	The result returned from the event execution.
	 */
	public void recordData(String methodEventName, long data) {
		recordData(methodEventName, new DataTypeLong(data));
	}
	
	
	/**
	 * Records the result from a method executing in the repast model execution, 
	 *  when the method has a return type String.
	 * @param methodEventName The name of the method/variable.
	 * @param data	The result returned from the event execution.
	 */
	public void recordData(String methodEventName, String data) {
		recordData(methodEventName, new DataTypeString(data));
	}

	
	/**
	 * Records the result from a method executing in the repast model execution, 
	 *  when the method has a return type boolean.
	 * @param methodEventName The name of the method/variable.
	 * @param data	The result returned from the event execution.
	 */
	public void recordData(String methodEventName, boolean data) {
		recordData(methodEventName, new DataTypeBoolean(data));
	}
	
	
	public String[] getVariableNames() {
		if (variableNamesList == null)
			retrieveVariableInformationFromFile();
		return variableNamesList;
	}

	public HashMap<String, String> getVariableTypes() {
		if (variableTypeMap == null)
			retrieveVariableInformationFromFile();
		return variableTypeMap;
	}
	
	
	public HashMap<String, Integer> getVariableIndices() {
		if (variableIndexMap == null)
			retrieveVariableInformationFromFile();
		return variableIndexMap;
	}
	
	
	/**
	 * Retrieves a matrix from the list of data recorded from method executions 
	 * in the model, and writes this matrix to the data file at the location
	 * provided in the constructor.
	 * @return boolean representing the success of these operations.
	 */
	public boolean writeRecentDataToFile() {
		FileWriter outputWriter;
		ArrayList<DataType[]> matrixFromRecentRun = createMatrixFromRun();
		try {
			// appends the text matrix to the the end of the existing text file
			outputWriter = new FileWriter(dataFile, true);
			try {
				outputWriter.write(convertMatrixToText(matrixFromRecentRun));
				// writes a blank line between data from different runs
				outputWriter.write("\n");
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			} finally {
				try {
					outputWriter.close();
				} catch (IOException e) {
					e.printStackTrace();
					return false;
				}
			}
		} catch (IOException e1) {
			e1.printStackTrace();
			return false;
		}
		return true;
	}
	
	
	/**
	 * Reads the list of DataRecord objects representing methods executed in 
	 * this model execution and their values, and creates a full matrix
	 * representing the value for each variable at each step in time.
	 * @return Matrix representing all data from a single repast model run.
	 */
	private ArrayList<DataType[]> createMatrixFromRun() {
		
		if (dataRecordList == null)
			throw new NullPointerException("The list of all data from the "
					+ "model execution run has not been created correctly.");
		
		/* Retrieve the list of method names and types from the data file
		   This allows this function to know what order the method values are
		   listed in within the data file, as well as the type of each method.
		   Stores info in variableNamesList, variableTypeMap, variableIndexMap. */
		retrieveVariableInformationFromFile();
		
		ArrayList<DataType[]> matrix = new ArrayList<DataType[]>();
		
		for (int i = 0; i < dataRecordList.size(); i++) {
			// array of each variable's value at this point in the execution:
			DataType[] nextDataStep = new DataType[numVariables];
	
			DataRecord nextDataRecord = dataRecordList.get(i);
			/* Name of the variable recorded at this step. 
			   This is the only value that might change from the
			   previous 'data step' (previous row in the matrix) */
			String currentVarName = nextDataRecord.variableName;
			int currVarIndex = variableIndexMap.get(currentVarName);
			for (int v = 0; v < numVariables; v++) {
				if (v != currVarIndex && matrix.size() > 0)
					nextDataStep[v] = matrix.get(matrix.size() - 1)[v];
				else if (v != currVarIndex)
					nextDataStep[v] = getUninitializedDataType(currentVarName);
				else if (v == currVarIndex)
					nextDataStep[currVarIndex] = nextDataRecord.data;
			}
			matrix.add(nextDataStep);
		}
		return matrix;
	}
	

	/**
	 * Parse and organize the data obtained from Repast model execution(s).
	 * Produces output formatted for use with the FSA creation program.
	 * @return An ArrayList of DataType arrays; each array represents the values
	 * of each variable at that single point in the execution.
	 */
	public ArrayList<DataType[]> getFullMatrixFromDataFile() {
		
		/* Retrieve the list of method names and types from the data file
		   This allows this function to know what order the method values are
		   listed in within the data file, as well as the type of each method.
		   Stores info in variableNamesList, variableTypeMap, variableIndexMap.
		 */
		retrieveVariableInformationFromFile();

		ArrayList<DataType[]> fullDataMatrix = new ArrayList<DataType[]>();
		
		try {
			Scanner scanFile = new Scanner(dataFile);
			// can ignore first two lines
			// they contain information about the methods and don't contain data
			scanFile.nextLine();
			scanFile.nextLine();
			
			while (scanFile.hasNextLine()) {
				// scan each line in the file
				String line = scanFile.nextLine();
				if (line.equals("") || line.equals("\n"))
					continue;

				String[] dataList = line.split(", ");
				DataType[] currentDataStep = new DataType[numVariables];
				
				for (int i = 0; i < numVariables; i++) {
					String data = dataList[i];
					String varName = variableNamesList[i];
					String varType = variableTypeMap.get(varName);
					currentDataStep[i] =
							getDataTypeObjectFromString(varType, data);
				}
				fullDataMatrix.add(currentDataStep);
			}
			scanFile.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return null;
		}
		
		return fullDataMatrix;
	}
	
	
	/**
	 * @param matrix The matrix to convert to text form
	 * @return Text representation of a matrix
	 */
	static private String convertMatrixToText(ArrayList<DataType[]> matrix) {
		String output = "";
		output += "null, null, null, null, null\n"; // represents the starting state
		for (DataType[] dataStep : matrix) {
			for (int i = 0; i < dataStep.length; i++) {
				if (dataStep[i] == null)
					output += "null";
				else
					output += dataStep[i].toString();
				if (i < dataStep.length - 1)
					output += ", ";
			}
			output += "\n";
		}
		return output;
	}
	
	private DataType getUninitializedDataType(String varName) {
		if (variableTypeMap == null) {
			throw new NullPointerException("Map of variable types was not " + 
					"initialized correctly. It is null");
		}

		String varType = variableTypeMap.get(varName);
		if (varType == null) {
			throw new NullPointerException("This variable's type was never " + 
					"defined in the variable type map");
		}
		else if (varType.equals("int"))
			return new DataTypeInt();
		else if (varType.equals("double"))
			return new DataTypeDouble();
		else if (varType.equals("String"))
			return new DataTypeString();
		else if (varType.equals("long"))
			return new DataTypeLong();
		else if (varType.equals("boolean"))
			return new DataTypeBoolean();
		return null;
	}
	
	
	/**
	 * Returns a DataType object that is created from converting the
	 * 	String data to the appropriate type, depending on the defined type.
	 * @param type The data type this String input should be converted to. 
	 * @param data A value as a String. "null" if uninitialized
	 * @return DataType object of the correct type, with the appropriate value
	 *   if initialized.
	 */
	private DataType getDataTypeObjectFromString(String type, String data) {
		if (type.equals("int"))
			return new DataTypeInt(data);
		else if (type.equals("double"))
			return new DataTypeDouble(data);
		else if (type.equals("String"))
			return new DataTypeString(data);
		else if (type.equals("long"))
			return new DataTypeLong(data);
		else if (type.equals("boolean"))
			return new DataTypeBoolean(data);
		return null;
	}
	
	
	/**
	 * Reads in the first two lines from the data storage file. 
	 * Reads and stores the method names (in the order they appear in each row 
	 *   of the matrix) and the method types.
	 * This is important to ensure that the data for each variable/method is
	 * 	 stored in the same column during each run.
	 * It is also important to know what type is assigned to each variable.
	 * Stores this information as global variables of this DataRecordManager.
	 * First two lines of the text file appear as follows:
	 * method1Name, method2Name, method3Name; i.e.: methodA, methodB, method3 
	 * method1Type, method2Type, method3Type; i.e.: boolean, int, double
	 * @return boolean representing the success of these operations
	 */
	private boolean retrieveVariableInformationFromFile() {
		try {
			Scanner scanFile = new Scanner(dataFile);
			// read in and store variable names and variable types:
			Scanner scanFirstLine = new Scanner(scanFile.nextLine());
			Scanner scanSecondLine = new Scanner(scanFile.nextLine());
			scanFirstLine.useDelimiter(", ");
			scanSecondLine.useDelimiter(", ");
			scanFile.close();
			
			variableIndexMap = new HashMap<String, Integer>();
			variableTypeMap = new HashMap<String, String>();
			variableNamesList = new String[numVariables];
			
			int i = 0;
			while (scanFirstLine.hasNext() && scanSecondLine.hasNext()) {
				if (i > numVariables) {
					// Invalid number of variables read from file header
					scanFirstLine.close();
					scanSecondLine.close();
					variableIndexMap = null;
					variableTypeMap = null;
					return false;
				}
				String varName = scanFirstLine.next();
				String varType = scanSecondLine.next();
				variableNamesList[i] = varName;
				variableIndexMap.put(varName, i);
				variableTypeMap.put(varName, varType);
				i++;
			}
			
			scanFirstLine.close();
			scanSecondLine.close();
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return false;
		}
		
		if (variableIndexMap.isEmpty() || variableIndexMap == null)
			throw new NullPointerException("The list of variable names was not read from the file correctly");	
		else if (variableTypeMap.isEmpty() || variableTypeMap == null)
			throw new NullPointerException("The list of variable types was not read from the file correctly");
		return true;
	}
}
	
	'''
	def generateDataType()'''
	package DataRecording;

public interface DataType extends Comparable<DataType> {
	public boolean isInitialized();
}
	'''
	def generateDataTypeBoolean()'''
	package DataRecording;

public class DataTypeBoolean implements DataType {
	
	private boolean dataValue;
	private boolean initialized;
	
	
	public DataTypeBoolean(boolean data) {
		this.dataValue = data;
		this.initialized = true;
	}
	
	
	/** Constructor for an uninitialized object (one with an unknown value). */	
	public DataTypeBoolean() {
		this.initialized = false;
	}
	
	
	public DataTypeBoolean(String dataStr) {
		dataStr = dataStr.trim();
		if (dataStr.contains("null")) {
			this.initialized = false;
		} else if (dataStr.equals("true")) {
			this.dataValue = true;
			this.initialized = true;
		} else if (dataStr.equals("false")) {
			this.dataValue = false;
			this.initialized = true;
		} else {
			throw new NullPointerException("\"" + dataStr + "\" is not a " + 
					"valid string for a boolean type!");
		}
	}
	
	
	public boolean isInitialized() {
		return initialized;
	}
	
	
	boolean getData() {
		if (!initialized)
			throw new NullPointerException("This DataType object has not yet" +
					" been initialized");
		return dataValue;
	}

	
	// how to indicate invalid value for a boolean?
	// this returns -99; when checking it; always check for equality first
	@Override
	public int compareTo(DataType o) {
		if (this.getData() == ((DataTypeBoolean)o).getData())
			return 0;
		return -99;
	}
	
	
	/** @return A String representation of this DataValue */
	public String toString() {
		if (initialized && dataValue)
			return "true";
		else if (initialized && !dataValue)
			return "false";
		else 
			return "null";
	}
}
	'''
	def generateDataTypeDouble()'''
	package DataRecording;

public class DataTypeDouble implements DataType {
	
	private double dataValue;
	private boolean initialized;
	
	
	public DataTypeDouble(double data) {
		this.dataValue = data;
		this.initialized = true;
	}
	

	/** Constructor for an uninitialized object (one with an unknown value). */
	public DataTypeDouble() {
		this.initialized = false;
	}
	
	
	public DataTypeDouble(String dataStr) {
		if (dataStr.contains("null")) {
			this.initialized = false;
		} else {
			this.dataValue = Double.parseDouble(dataStr);
			this.initialized = true;
		}
	}
	
	
	public boolean isInitialized() {
		return initialized;
	}
	
	
	double getData() {
		if (!initialized)
			throw new NullPointerException("This DataType object has not yet" +
					" been initialized");
		return dataValue;
	}
	

	@Override
	public int compareTo(DataType o) {
		double d2 = ((DataTypeDouble)o).getData();
		if (this.getData() < d2) {
			return -1;
		}
		else if (this.getData() > d2) {
			return 1;
		}
		else
			return 0;
	}
	
	
	/** @return A String representation of this DataValue */
	public String toString() {
		if (initialized)
			return dataValue + "";
		else 
			return "null";
	}
}
	
	'''
	def generateDataTypeInt()'''
	package DataRecording;

public class DataTypeInt implements DataType {
	
	private int dataValue;
	private boolean initialized;
	
	
	public DataTypeInt(int data) {
		this.dataValue = data;
		this.initialized = true;
	}
	
	/** Constructor for an uninitialized object (one with an unknown value). */	
	public DataTypeInt() {
		this.initialized = false;
	}
	
	
	public DataTypeInt(String dataStr) {
		if (dataStr.contains("null")) {
			this.initialized = false;
		} else {
			this.dataValue = Integer.parseInt(dataStr);
			this.initialized = true;
		}
	}
	
	
	public boolean isInitialized() {
		return initialized;
	}
	
	
	int getData() {
		if (!initialized)
			throw new NullPointerException("This DataType object has not yet" +
					" been initialized");
		return dataValue;
	}
	

	@Override
	public int compareTo(DataType o) {
		int int2 = ((DataTypeInt)o).getData();
		if (this.getData() < int2)
			return -1;
		else if (this.getData() > int2)
			return 1;
		else 
			return 0;
	}
	
	
	/** @return A String representation of this DataValue */
	public String toString() {
		if (initialized)
			return dataValue + "";
		else 
			return "null";
	}
}
	'''
	def generateDataTypeLong()'''
	package DataRecording;

public class DataTypeLong implements DataType {
	
	private long dataValue;
	private boolean initialized;
	
	
	public DataTypeLong(long data) {
		this.dataValue = data;
		this.initialized = true;
	}
	

	/** Constructor for an uninitialized object (one with an unknown value). */
	public DataTypeLong() {
		this.initialized = false;
	}
	
	
	public DataTypeLong(String dataStr) {
		if (dataStr.contains("null")) {
			this.initialized = false;
		} else {
			this.dataValue = Long.parseLong(dataStr);
			this.initialized = true;
		}
	}
	
	
	public boolean isInitialized() {
		return initialized;
	}
	
	
	long getData() {
		if (!initialized)
			throw new NullPointerException("This DataType object has not yet" +
					" been initialized");
		return dataValue;
	}
	

	@Override
	public int compareTo(DataType o) {
		long data2 = ((DataTypeLong)o).getData();
		if (this.getData() < data2) {
			return -1;
		}
		else if (this.getData() > data2) {
			return 1;
		}
		else
			return 0;
	}
	
	
	/** @return A String representation of this long DataValue */
	public String toString() {
		if (initialized)
			return dataValue + "";
		else 
			return "null";
	}
}
	
	'''
	def generateDataTypeString()'''
	package DataRecording;

public class DataTypeString implements DataType {
	
	// Strings with leading or trailing spaces will have these spaces removed
	private String dataValue;
	private boolean initialized;
	
	
	public DataTypeString(String data) {
		String dataTrimmed = data.trim();

		if (dataTrimmed.equals("null")) {
			this.initialized = false;
		} else {
			this.dataValue = dataTrimmed;
			this.initialized = true;
		}
	}
	
	
	/** Constructor for an uninitialized object (one with an unknown value). */	
	public DataTypeString() {
		this.initialized = false;
	}
	
	public boolean isInitialized() {
		return initialized;
	}
	
	
	String getData() {
		if (!initialized)
			throw new NullPointerException("This DataType object has not yet" +
					" been initialized");
		return dataValue;
	}
	

	@Override
	public int compareTo(DataType o) {
		return this.getData().compareTo(((DataTypeString)o).getData());
	}
	
	
	/** @return A String representation of this DataValue */
	public String toString() {
		if (initialized)
			return dataValue + "";
		else 
			return "null";
	}
}
	
	'''
	def generateFileGenerator()'''
	package projectManagement;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;


public class FileGenerator {

	String answerPackage; 	// = "answers"; // name of the package the AspectJ package will be located in
	String answerName; 		//  = "Answer5"; // name of the AspectJ answer file and class
	
	// Path of the Repast model (packageName.ModelClassName)
	String modelPackageName;
	
	// Path of the data storage file
	String dataFileLocation;
	
	// Number of methods to record from the model.
	// Later referred to as the number of variables.
	int numberMethods;	
	
	HashMap<String, String> validTypes;
	
	
	/**
	 * Constructor for a new FileGenerator object. 
	 * @param modelPackageName The fully qualified name of the package and class
	 *  in which the model of interest is located
	 */
	public FileGenerator(String modelPackageName) {
		this.modelPackageName = modelPackageName;
		this.numberMethods = -1;
		defineValidTypes();
	}
	
	
	public int getNumVariables() {
		return numberMethods;
	}
	
	public String getDataFileLocation() {
		return dataFileLocation;
	}
	
	
	/** 
	 * These are the valid types that this program supports by having a
	 * DataType interface implementation that represents data of these types.
     * The proccessInput method in the FileGenerator class uses these types to
     * validate the return types provided to the FileGenerator from the DSL.
	 */
	private void defineValidTypes() {
		validTypes = new HashMap<String, String>();
		validTypes.put("boolean", "boolean");
		validTypes.put("double", "double");
		validTypes.put("int", "int");
		validTypes.put("long", "long");
		validTypes.put("string", "String");
	}
	
	
	/**
	 * Generates the AspectJ code needed to record executions of the specified
	 * methods, and writes this AspectJ code to a .aj file.
	 * Generates the list of method names and types, and writes to a txt file.
	 * 
	 * Format of each string describing a method to record:
	 * fully.qualified.methodName, paramType1, paramType2, returnType
	 * with as many parameter types as applicable, 0..*
	 * 	
	 * @param answerFileName The desired name of the AspectJ answer file
	 * @param answerPackage The desired package location for the AspectJ file
	 * @param inputMethodInfo List of Strings describing the methods to record
	 */
	public void generate(String answerPackageName, String answerFileName, 
			String[] methods) {
		// strips any file extension from the answer file name
		if (answerFileName.indexOf(".") > 0)
			this.answerName =
					answerFileName.substring(0, answerFileName.indexOf("."));
		if (methods.length < 1)
			throw new NullPointerException("Must provide information about one" 
					+ "or more methods to record.");
		this.answerName = answerFileName;
		this.answerPackage = answerPackageName;
		// this can be modified to a different location that is better suited
		this.dataFileLocation = "src/" + answerPackage + "/" + answerName + "Data.txt";
		this.numberMethods = methods.length;
		
		MethodInfo[] mList = processInput(methods);

		String aspectContentToWrite = getAspectJContent(mList);
		writeAspectJContentToFile(aspectContentToWrite);
		writeVariableListToFile(mList);
	}
	
	
	/**
	 * Processes the information provided about each method to record, and
	 * stores this information in an instance of the MethodInfo class to make
	 * access of this information easier when generating the AspectJ code.	
	 * Modify this function to process input correctly if the format changes.
	 * @param inputMethodInfo
	 * @return list of MethodInfo objects; each represents one method to record
	 */
	private MethodInfo[] processInput(String[] inputMethodInfo) {
		// could make ignore invalid method descriptions, or throw error?
		MethodInfo[] methods = new MethodInfo[inputMethodInfo.length];
		for (int i = 0; i < inputMethodInfo.length; i++) {
			String[] methodInfoAsList = inputMethodInfo[i].split(",");
			for (int j = 0; j < methodInfoAsList.length; j++)
				methodInfoAsList[j] = methodInfoAsList[j].trim();
			methods[i] = new MethodInfo(methodInfoAsList);
		}
		return methods;
	}

	
	/**
	 * Class representing a single method in the repast model that should be
	 * recorded.
	 */
	private class MethodInfo {
		String qualifiedMethodName;
		String shortMethodName;
		String paramTypeList;
		String returnType;
		
		//[qualifiedMethodName, params..., returnType]
		public MethodInfo(String[] description) {
			// throw error if description.length < 2
			// which should have been caught by DSL (?)
			qualifiedMethodName = description[0];
			shortMethodName = getShortMethodName(qualifiedMethodName);
			
			returnType = description[description.length - 1];
			returnType = validTypes.get(returnType.trim().toLowerCase());
			if (returnType == null)
				throw new NullPointerException("The return type (" + returnType
						+ ") specified for" +
						" the method named " + shortMethodName + " is not a " +
						" valid type supported by this recording/FSA program");
			
			if (description.length > 2) {
				String[] paramTypes = Arrays.copyOfRange(description, 1,
						description.length - 1);
				paramTypeList = createParamTypeString(paramTypes);
			}
			else
				paramTypeList = "";
		}
		
		/** @returns Array of parameter types as a comma delimited String. */
		private String createParamTypeString(String[] paramTypeList) {
			String paramTypesString = "";
			int numAdded = 1;
			for (String type : paramTypeList) {
				paramTypesString += type;
				// if not the last parameter, add comma and space:
				if (numAdded++ != paramTypeList.length)
					paramTypesString += ", ";
			}
			return paramTypesString;
		}
		
		
		/*
		 * This method can be used for testing & manually verifying the
		 * processInput function and MethodInfo constructor were modified
		 * correctly, if the DSL input format is changed.
		 */
		void printMethodInfo() {
			System.out.println("\nMethod name: " + qualifiedMethodName +
					"\nShort method name: " + shortMethodName);
			System.out.print("Parameter Types: ");
			if (paramTypeList.equals(""))
				System.out.println("no params");
			else
				System.out.println(paramTypeList);
			System.out.println("\nReturn type: " + returnType);
		}
	
	}
	

	/* This method generates a String that represents the content that 
	 * the AspectJ advice file should have in order to record the
	 * occurrences of each of the specified methods from the repast model.
	 * 
	 * pointcut METHODNAMEEvent():
	 *    call(RETURNTYPE METHODNAME(PARAMTYPELIST);
	 * RETURNTYPE around(): METHODNAMEEvent() {
	 *    RETURNTYPE result = proceed();
	 *    dataMgr.recordData("METHODNAME", result);
	 *    return result;
	 * }
	 *  */
	/**
	 * Generates a String that represents the content that the AspectJ advice
	 * file should contain in order to record the executions of each of the
	 * specified methods from the repast model.
	 * @param methodEventsToRecord
	 * @return
	 */
	private String getAspectJContent(MethodInfo[] methodEventsToRecord) {
		// create AspectJ answer heading:
		String answer = "package " + answerPackage + ";\n\n";
		answer += "import DataRecording.DataRecordManager;\n";
		answer += "public aspect " + answerName + " {\n\n";
		answer += "\tint numVariables = " + methodEventsToRecord.length + ";\n";
		answer += "\tString dataStorageLocation = \"" + dataFileLocation + "\";\n\n";
		answer += "\tDataRecordManager dataMgr;\n\n";
		
		// generate code to add functionality to setup() and buildModel() 
		answer += getAspectJCodeToManageData();
		answer += "\n\n";
		
		// add AspectJ pointcuts & advice for each method to record:
		for (MethodInfo m : methodEventsToRecord)
			answer += getAspectJCodeToRecordMethodExecution(m);
		
		answer += "\n" + "}"; // closing bracket for file
		return answer;
	}
	
	
	/**
	 * Generates the AspectJ pointcut and advice to record a single method.
	 * 
	 * pointcut METHODNAMEEvent():
	 *    call(RETURNTYPE METHODNAME(PARAMLIST items);
	 * RETURNTYPE around(): METHODNAMEEvent() {
	 *    RETURNTYPE result = proceed();
	 *    *record*
	 *    return result;
	 * }
	 * 
	 * @param method Information representing a single method in the model
	 * @return
	 */
	private static String getAspectJCodeToRecordMethodExecution(MethodInfo method) {
		String aspectJPointcut = "\tpointcut " + method.shortMethodName + "Event():\n"
				+ "\t\texecution(" + method.returnType + " " + method.qualifiedMethodName 
				+ "(" + method.paramTypeList + "));\n";
		String aspectJAdvice = 
				"\t" + method.returnType + " around(): " + method.shortMethodName + "Event() {\n"
				+ "\t\t" + method.returnType + " result = proceed();\n"
				+ "\t\t" + getDataRecordingTemplate(method.shortMethodName) + "\n"
				+ "\t\treturn result;\n"
				+ "\t}"
				+ "\n\n";
		return aspectJPointcut + aspectJAdvice;
	}
	
	
	/**
	 * Generate a String representing the code needed to record data. Modify
	 * if the technique for recording data changes.
	 * @param methodName The name of the method that this code should record
	 * @return The format used to record a single execution of this method.
	 */
	private static String getDataRecordingTemplate(String methodName) {
		return ("dataMgr.recordData(\"" + methodName + "\", result);");
	}
	
	
	/**
	 * Generates and returns the AspectJ code that will be used to instantiate
	 * a new DataRecordManager for the execution of the model. Generates code
	 * to instantiate the development of the FSA from the data from the run.
	 * 	
	 * after() : execution(void segregation.SegregationBatch.setup()) {
	 *	dataMgr = new DataRecordManager(numVariables, dataStorageLocation);
	 * }
	 * after() : execution(void segregation.SegregationBatch.atEnd()) {
	 * 	dataMgr.writeRecentDataToFile();
	 * }
	 * 
	 * @return AspectJ code for invoking the data recording and FSA creation
	 */
	private String getAspectJCodeToManageData() {
		String output = "";
		output += "\tafter() : " 
				+ " execution(void " + modelPackageName + ".setup()) {";
		output += "\n\t\tdataMgr = new DataRecordManager(numVariables, dataStorageLocation);";
		output += "\n\t}";
		
		output += "\n\tafter() : " 
				+ "execution(void " + modelPackageName + ".atEnd()) {";
		output += "\n\t\tdataMgr.writeRecentDataToFile();";
		output += "\n\t}";
		return output;
	}
	
	
	/** @returns String method name without package and class name. */
	private static String getShortMethodName(String qualifiedMethodName) {
		int lastIndex = qualifiedMethodName.lastIndexOf('.');
		return qualifiedMethodName.substring(lastIndex + 1);
	}
	
	

	
	
	/**
	 * Writes the AspectJ code to the aspectJ file.
	 * @param String content to write to an AspectJ file.
	 */
	private boolean writeAspectJContentToFile(String content) {
		// should this return boolean representing success?
		if (answerPackage == null || answerName == null) {
			throw new NullPointerException("AspectJ destination package or " +
					"file name is undefined");
		}
		String destinationLocation = "src/" + answerPackage + "/" + answerName + ".aj";
		File aspectJFile = new File(destinationLocation);
		FileWriter output;
		try {
			//dataFile.createNewFile();
			output = new FileWriter(aspectJFile);
			try {
				output.write(content);
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			} finally {
				try {
					output.close();
				} catch (IOException e) {
					e.printStackTrace();
					return false;
				}
			}
		} catch (IOException e1) {
			e1.printStackTrace();
			return false;
		}
		return true;
	}
	
	
	/**
	 * Writes the list of method/variables names and types to the data file.
	 * @param methodList list of methods recorded
	 * @return
	 */
	private boolean writeVariableListToFile(MethodInfo[] methodList) {
		
		String methodNames = "";
		String methodTypes = "";
		for (int i = 0; i < methodList.length; i++) {
			methodNames += methodList[i].shortMethodName;
			methodTypes += methodList[i].returnType;
			if (i < methodList.length - 1) {
				methodNames += ", ";
				methodTypes += ", ";
			}
		}
		
		String destinationLocation = "src/" + answerPackage + "/" + answerName + "Data.txt";
		
		File dataFile = new File(destinationLocation);
		FileWriter outputWriter;
		try {
			//dataFile.createNewFile();
			outputWriter = new FileWriter(dataFile);
			try {
				outputWriter.write(methodNames + "\n");
				outputWriter.write(methodTypes + "\n");
			} catch (IOException e) {
				e.printStackTrace();
				return false;
			} finally {
				try {
					outputWriter.close();
				} catch (IOException e) {
					e.printStackTrace();
					return false;
				}
			}
		} catch (IOException e1) {
			e1.printStackTrace();
			return false;
		}
		return true;
	}

}

	
	'''
	
	def generateDriver(Evidences e)'''
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;


public class Main {
	public static void main(String[] args)
	{
		Query q = new Query("«e.query»");
		EvidenceTesting e = new EvidenceTesting("Experiment 1", q);
		String LTL = e.toLTL();
		System.out.println(LTL);
		
		try{
			File file =new File("«e.path»" + "/«e.promela».pml");
			FileWriter fileWritter = new FileWriter(file,true);
	        BufferedWriter bufferWritter = new BufferedWriter(fileWritter);
	        bufferWritter.write("\n" + LTL);
	        bufferWritter.close();
			
			ProcessBuilder builder = new ProcessBuilder(
		            "cmd.exe", "/c", "cd \"«e.path»\" && spin -a «e.promela».pml && gcc -o «e.promela».exe pan.c && «e.promela».exe -a");
		        builder.redirectErrorStream(true);
		        Process p = builder.start();
		        BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));
		        String line;
		        while (true) {
		            line = r.readLine();
		            if (line == null) { break; }
		            System.out.println(line);
		        }
		        
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
		
	}

}
	
	'''
	def generateEvidenceTesting() '''
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * This class will take a query and convert it into LTL 
 * @author krdou_000
 * @version 11/2/15
 */
public class EvidenceTesting {
	String hypothesisName;
	Query query;
	Document dom;
	/**
	 * Constructor for HypothesisTesting
	 * 
	 * @param name The identifier for the hypothesis
	 * @param q The temporal query from the DSL
	 */
	public EvidenceTesting(String name, Query q )
	{
		this.hypothesisName = name;
		this.query = q;
	}
	
	/**
	 * Replaces P, S, R, X, and Z from a temporal pattern template with their actual program names
	 * @return ltlFormula The formula as it will be passed to SPIN
	 */
	public String toLTL()
	{
		parseXmlFile();
		String ltlFormula = getFormulaFromXml();
		ArrayList<String> eventListInOrder = replaceCharsWithEvents(ltlFormula);
		String[] placeholders = {"P", "Q", "R", "S", "T", "Z"};
		for(int i = 0; i < placeholders.length; i++)
		{
			ltlFormula = ltlFormula.replaceAll(placeholders[i], "\\$");
		}
		for(String e : eventListInOrder)
		{
			ltlFormula = ltlFormula.replaceFirst("\\$", e);
		}
		return ltlFormula;
	}
	
	private ArrayList<String> replaceCharsWithEvents(String ltlFormula) {
		char[] placeholders = {'P', 'Q', 'R', 'S', 'T', 'Z'};
		ArrayList<String> eventListInOrder = new ArrayList<String>();
		for(int i = 0; i < ltlFormula.length(); i++)
		{
			for(int j = 0; j < placeholders.length; j++)
			{
				if(ltlFormula.charAt(i) == placeholders[j])
				{
					eventListInOrder.add(Character.toString(ltlFormula.charAt(i)));
				}
			}
		}
		ArrayList<String> eventListSorted = new ArrayList<String>();
		for(String s : eventListInOrder)
		{
			eventListSorted.add(s);
		}
		Collections.sort(eventListSorted);
		HashMap<String, Integer> letterOrder = new HashMap<String, Integer>();
		int place = 0;
		for(int i = 0; i < eventListSorted.size(); i++)
		{
			if(i != 0)
			{
				if(eventListSorted.get(i).compareTo(eventListSorted.get(i-1)) > 0)
				{
					letterOrder.put(eventListSorted.get(i), place);
					place++;
				}
			}
			else
			{
				letterOrder.put(eventListSorted.get(i), place);
				place++;
			}
		}
		for(int i = 0; i < eventListInOrder.size(); i++)
		{
			eventListInOrder.set(i, query.getEvents().get(letterOrder.get(eventListInOrder.get(i))));
		}
		return eventListInOrder;
	}

	/**
	 * Getter for hypothesis name
	 * 
	 * @return hypothesisName The identifier for this hypothesis.
	 */
	public String getHypothesisName() {
		return hypothesisName;
	}

	/**
	 * Setter for Hypothesis name
	 * 
	 * @param hypothesisName The new identifier for the hypothesis
	 */
	public void setHypothesisName(String hypothesisName) {
		this.hypothesisName = hypothesisName;
	}

	/**
	 * Getter for hypothesis name
	 * 
	 * @return hypothesisName The identifier for this hypothesis.
	 */
	public Query getQuery() {
		return query;
	}

	public void setQuery(Query q) {
		this.query = q;
	}
	
	/**
	 * Gets a global dom object for the xml file that holds the temporal specification patterns.
	 * 
	 */
	private void parseXmlFile(){
		//get the factory
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		
		try {
			
			//Using factory get an instance of document builder
			DocumentBuilder db = dbf.newDocumentBuilder();
			
			//parse using builder to get DOM representation of the XML file
			dom = db.parse("C:\\Users\\krdou_000\\Documents\\Repast Workspace\\LTLtoXML\\Patterns.xml");
			

		}catch(ParserConfigurationException pce) {
			pce.printStackTrace();
		}catch(SAXException se) {
			se.printStackTrace();
		}catch(IOException ioe) {
			ioe.printStackTrace();
		}
	}
	
	/**
	 * Finds the formula that matches the query from the patterns.xml file.
	 * @return formula The pattern formula template.
	 */
	private String getFormulaFromXml()
	{
		String formula = "not identified";
		Element docEle = dom.getDocumentElement();
		
		NodeList nl = docEle.getElementsByTagName(query.getPatternType());
		if(nl != null && nl.getLength() > 0) {
			for(int i = 0 ; i < nl.getLength();i++) 
			{
				Element el = (Element)nl.item(i);
				formula = getTextValue(el, query.getPostfix());
			}
		}
		return formula;
	}
	
	/**
	 * Helper function that gets the value of a text node in xml
	 * 
	 * @param ele The DOM element that we want to get the value of
	 * @param tagName The tag name of the child element of ele
	 * @return textVal The value of the xml text node 
	 */
	private String getTextValue(Element ele, String tagName) {
		String textVal = null;
		NodeList nl = ele.getElementsByTagName(tagName);
		if(nl != null && nl.getLength() > 0) {
			Element el = (Element)nl.item(0);
			textVal = el.getFirstChild().getNodeValue();
		}

		return textVal;
	}

}
	
	'''
	def generateQuery() '''
import java.util.ArrayList;


public class Query {

	private ArrayList<String> events = new ArrayList<String>();
	private String query;
	private String patternType;
	private boolean hasPostfix = false;
	private String postfix = "Globally";
	private String postfixIdentifier;

	public final String[] patternIdentifier = {"absent", "eventually exists", "always exists", "precedes", "leads to"};
	public final String[] patterns = {"Absence", "Existence", "Universality", "Precedence", "Response"};

	public final String[] postfixIdentifiers = {"before", "until", "between", "after"};
	public final String[] postfixes = {"Before", "AfterUntil", "Between", "After"};

	/**
	 * Creates a new query object.
	 * 
	 * @param queryIn The query from the DSL as a string. For example, "LookingForNewSite = true is absent"
	 */
	public Query(String queryIn)
	{
		this.query = queryIn;
		detectEvents();
	}

	/**
	 * Helper function that detects the type of pattern the query is by looking for keywords.
	 */
	private void detectPattern()
	{
		for(int i = 0; i < patternIdentifier.length; i++)
		{
			if(query.contains(patternIdentifier[i]))
			{
				patternType = patterns[i];
			}
		}
	}

	/**
	 * Helper function that detects if the pattern has a postfix by looking for keywords.
	 */
	private void detectPostfix()
	{
		for(int i = 0; i < postfixIdentifiers.length; i++)
		{
			if(query.contains(postfixIdentifiers[i]))
			{
				postfix = postfixes[i];
				postfixIdentifier = postfixIdentifiers[i];
				hasPostfix = true;
				break;
			}
		}
	}

	/**
	 * Helper function that detects the events in the query by searching before and after the pattern keywords
	 * Calls detectPattern and detectPostfix because they are preconditions.
	 */
	private void detectEvents()
	{
		detectPattern();
		detectPostfix();
		switch(patternType)
		{
		case "Absence":
			String[] primaryEvents = {query.substring(0, query.indexOf("is") - 1)};
			addPostfix(primaryEvents);
			break;
		case "Existence":
			String[] primaryEvents1 = {query.substring(0, query.indexOf("eventually") - 1)};
			addPostfix(primaryEvents1);
			break;
		case "Universality":
			String[] primaryEvents2 = {query.substring(0, query.indexOf("always") - 1)};
			addPostfix(primaryEvents2);
			break;
		case "Precedence":
			String firstEvent = query.substring(0, query.indexOf("precedes") - 1);
			String secondEvent;
			if(hasPostfix)
			{
				secondEvent = query.substring(query.indexOf("precedes") + 9, query.indexOf(postfixIdentifier) - 1);
			}
			else
			{
				secondEvent = query.substring(query.indexOf("precedes") + 9);
			}
			String[] primaryEvents3 = {firstEvent, secondEvent};//untested, fear of nulls
			addPostfix(primaryEvents3);
			break;
		case "Response":
			String firstEvent1 = query.substring(0, query.indexOf("leads") - 1);
			String secondEvent1;
			if(hasPostfix)
			{
				secondEvent1 = query.substring(query.indexOf("to") + 3, query.indexOf(postfixIdentifier) - 1);
			}
			else
			{
				secondEvent1 = query.substring(query.indexOf("to") + 3);
			}
			String[] primaryEvents4 = {firstEvent1, secondEvent1};//untested, fear of nulls
			addPostfix(primaryEvents4);
			break;
		default:
			break;

		}
	}

	private void addPostfix(String[] primaryEvents)
	{
		switch(postfix)
		{
		case "Before":
			addPrimaryEvents(primaryEvents);
			events.add(query.substring(query.indexOf("before")));
			break;
		case "AfterUntil":
			addPrimaryEvents(primaryEvents);
			events.add(query.substring(query.indexOf("after") + 6, query.indexOf("until") - 1));
			events.add(query.substring(query.indexOf("until") + 6));
			break;
		case "Between":
			addPrimaryEvents(primaryEvents);
			events.add(query.substring(query.indexOf("between") + 8, query.indexOf("and") - 1));
			events.add(query.substring(query.indexOf("and") + 4));
			break;
		case "After":
			addPrimaryEvents(primaryEvents);
			events.add(query.substring(query.indexOf("after") + 6));
			break;
		default:
			addPrimaryEvents(primaryEvents);
			break;
		}
	}

	private void addPrimaryEvents(String[] eventsIn)
	{
		for(int i = 0; i < eventsIn.length; i++)
		{
			events.add(eventsIn[i]);
		}
	}

	public boolean hasPostfix() {
		return hasPostfix;
	}

	public void setHasPostfix(boolean hasPostfix) {
		this.hasPostfix = hasPostfix;
	}

	public String getPostfix() {
		return postfix;
	}

	public void setPostfix(String postfix) {
		this.postfix = postfix;
	}

	/**
	 * Gets the pattern type
	 * 
	 * @return patternType The name of the specification pattern used in the query
	 */
	public String getPatternType() {
		return patternType;
	}

	/**
	 * Sets the patterns type
	 * 
	 * @param patternType The name of the new specification pattern to be used in the query
	 */
	public void setPatternType(String patternType) {
		this.patternType = patternType;
	}

	/**
	 * Gets the list of events
	 * 
	 * @return patternType The name of the specification pattern used in the query
	 */
	public ArrayList<String> getEvents() {
		return events;
	}

	/**
	 * Sets the list of events
	 * 
	 * @param e the new list of events
	 */
	public void setEvents(ArrayList<String> e) {
		this.events = e;
	}
}
	
	'''
}
